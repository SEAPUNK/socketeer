Socketeer Protocol
===

ver. **1**

- [websocket](#websocket)
- [handshake](#handshake)
- [protocol version](#protocol-version-query)
- [heartbeats](#heartbeats)
- [session resuming](#session-resuming)
- [event messages](#event-messages)
- [action message](#action-messages)
- [action response messages](#action-response-messages)

websocket
---

Socketeer relies on an [RFC6455](https://tools.ietf.org/html/rfc6455)-compliant websocket implementation library. The Node.js version uses the [ws](https://github.com/websockets/ws/) package.

Browser support: https://en.wikipedia.org/wiki/WebSocket#Browser_implementation

handshake
---

When the client first connects, before it can do anything else, it **must** complete the handshake.

Socketeer's handshake consists of three parts, done in order:

* Protocol version query
* Heartbeat interval set message
* Session resume token query

If the handshake is done out of order, or an unexpected message is received, then the connection must be closed.

The handshake has a configurable timeout of `handshakeTimeout`, which defaults to 10000ms (10 seconds). If the handshake does not complete in that time, then the connection must be closed.

protocol version
---

Protocol version query is used to determine if the client's version of Socketeer is compatible with the server. The message is such:

`v{VERSION}` where `{VERSION}` is the protocol version (in this case, `1`)

If the server's protocol version is not compatible with the client's protocol version, then the server must close the connection immediately.

If it matches, then the server will respond with the heartbeat set interval message.

heartbeats
---

Socketeer does its own form of heartbeats, because the Web API's websockets' ping/pongs do not have an API, and are implemented differently across platforms. <sup>[[1]](http://stackoverflow.com/a/10586583)</sup>

The Socketeer server is the "master" for heartbeats. It sets the interval, is the only one that sends the "ping"s. The Socketeer client, upon receiving the server's heartbeat message must immediately respond with the "pong"s.

The heartbeat set interval message is as follows:

`hi{INT}`, where `{INT}` is a positive integer that indicates how long in milliseconds the interval between each heartbeat will be.

Where `{INT}` is a positive integer that indicates how long in milliseconds the interval between each heartbeat will be.

The heartbeat mesage is a single `h`, regardless of it being "ping" or "pong".

Heartbeat flow is as such:

1. Server is started, and configured with a `server heartbeatTimeout` and `heartbeatInterval`.
    - `server heartbeatTimeout` is the span of time in milliseconds to wait for the client's "pong" message before closing (or "timing out") the connection to the client.
    - `heartbeatInterval` is the span of time in milliseconds to wait before sending another "ping" message.
2. Client is configured with a `client heartbeatTimeout`, and begins the connection to the server.
    - `client heartbeatTimeout` is the span of time in milliseconds to wait for the server's "ping" message before closing (or "timing out") the connection to the server.
3. Once the client is connected, the client awaits the heartbeat interval set message. Client ignores all messages except for heartbeat interval set messages.
    - If the server does not send a heartbeat message within the `client heartbeatTimeout` time, then time out the connection.
4. Server sends the heartbeat interval set message.
    - Client begins the heartbeat timeout, with the time of `heartbeatInterval + client heartbeatTimeout`. If a "ping" is not sent from the server within that time, then the client closes the connection.
    - Client is now "ready", and will now accept Socketeer messages.
5. Server sends a "ping" heartbeat message `heartbeatInterval` milliseconds after sending the heartbeat interval set message.
    - Client stops the existing heartbeat timeout, and starts a new one, with the time of (`heartbeatInterval + client heartbeatTimeout`)
    - Client immediately responds with a "pong" heartbeat message.
        + If the server does not receive a "pong" message within the `server heartbeatTimeout` time, then close the connection.
6. Server continuously sends a "ping" heartbeat message `heartbeatInterval` milliseconds after sending the last heartbeat message.
    - Client handles the heartbeats exactly how it handles heartbeats in step 5.

session resuming
---

Socketeer supports session resuming, which means that if a socket disconnects (due to an error, a timeout, or a simple close), Socketeer won't assume that the client is "closed" until after the configured session resume timeout.

After receiving the heartbeat set interval message and if the connection is not an attempt to resume the session, the client must check if the server supports session resuming by trying to get a session resume token. The message is as follows:

`r?`

When the server receives the query, it must do one of two things:

- If the server does *not* support session resuming, it must respond with `r`, so the client knows that the server is not going to give it a token.
- If the server *does* support session resuming, then it must generate a unique token (preferably long, and cryptographically secure) so both the server and client can store it for future use, and respond with `r:{TOKEN}`, where `{TOKEN}` is the generated token.

Once the client disconnects (or gets disconnected), then the session resume timeout begins.

To resume the session, the client must reconnect, start the handshake, and after receiving the heartbeat set interval message, authenticate with the server for session resuming. The message format is as follows:

`r@{TOKEN}`

Where `{TOKEN}` is the session resuming token. For example, if the server responded with `r:abc123`, then the client must send `r@abc123`.

The server then checks the token, and makes sure it passes the following conditions:

- A session resume timeout exists for the session.
- Client attempted session resuming before the session resume timeout (in which the session resume timeout is stopped and removed).
- Unless the server is configured to not check, client's IP is the same as the old client's IP.

If the server support session resuming, and the session exists, then server must respond with `r+`, and send any pending messages. Else, the server must respond with `r-`, and the client proceeds as if it was a new connection.


event messages
---

Event messages have the following structure:

```json
{
    "e": "event-name",
    "d": {
        "some": "data"
    }
}
```

- `e` is the event name.
- `d` is the event data.

action messages
---

Action messages have the following structure:

```json
{
    "i": 123,
    "a": "action-name",
    "d": {
        "some": "data"
    }
}
```

The server must respond to action messages.

- `i` is the action ID. The receiver of the action responds to the action by echoing the ID value, so it can be properly handled.
- `a` is the action name.
- `d` is the action data.

action response messages
---

```json
{
    "i": 123,
    "s": 0,
    "d": {
        "some": "data"
    }
}
```

- `i` is the action ID. See how action IDs are used in the action message documentation.
- `s` is the action response status. This is a number, which can be one of the following:
    + `0` - "OK": Action went fine.
    + `1` - "NONEXISTENT": Action does not exist (client did not set up a handler for it)
    + `2` - "ERROR": An error occured while calling the action handler.
- `d` is the action data. If `s` is not `0`, then `d` may be an error message.
